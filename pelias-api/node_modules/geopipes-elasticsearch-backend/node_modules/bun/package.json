{
  "name": "bun",
  "version": "0.0.10",
  "description": "A useful container for streams",
  "main": "lib/bun.js",
  "scripts": {
    "test": "mocha -R tap"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/naomik/bun.git"
  },
  "keywords": [
    "stream",
    "streams2",
    "bun"
  ],
  "engines": {
    "node": "~0.10.12"
  },
  "author": {
    "name": "naomik",
    "email": "naomi@fknsrs.biz"
  },
  "license": "BSD",
  "readmeFilename": "README.md",
  "devDependencies": {
    "mocha": "~1.11.0"
  },
  "readme": "bun  ![build status][build_status]\n===\n\nWe've all pondered, \"But what do I do with it?\" The answer is universal: Wrap it\nin a bun! **bun** wraps a series of streams into a single\n`stream.Duplex`-compliant unit.\n\nA Possible And Likely Scenario\n------------------------------\n\nSay you have an existing module with an implentation like this\n\n```js\n// my-transport.js\nencryptor.pipe(compressor).pipe(socket).pipe(decompressor).pipe(decryptor);\n```\n\nTotally believable, right? Now each time someone wants to use your module, you\nhave to do something like this\n\n```js\n// too much work!\nclient.pipe(encryptor)\n      .pipe(compressor)\n      .pipe(socket)\n      .pipe(decompressor)\n      .pipe(decryptor)\n      .pipe(client);\n```\n\nGross! Puke! This is horribly inconvenient and ugly for the end user! Let's look\nat a **better solution**\n\n```js\n// defined in my-transport.js\nmodule.service = bun([encryptor, compressor, socket, decompressor, decryptor]);\n\n// used in client\nvar transport = require(\"./my-transport\");\nclient.pipe(transport.service).pipe(client);\n```\n\nHot cross buns! **bun** is amazing!\n\n\nExample\n-------\n\n```js\nvar  stream = require(\"stream\"),\n     bun    = require(\"bun\");\n\n// stream generator\nvar createStream = function createStream(id) {\n  var s = new stream.Transform({encoding: \"utf8\"});\n  s._transform = function _transform(str, encoding, done) {\n    this.push(\"(\" + id + \" \" + str + \")\");\n    done();\n  };\n  return s;\n};\n\n// create some streams\nvar streams = [\"G\", \"O\", \"D\"].map(function(id) {\n  return createStream(id);\n});\n\n// wrap the streams in a bun!\nvar hotdog = bun(streams);\n\n// connect hotdog to stdout\nhotdog.pipe(process.stdout);\n\n// use the hotdog\nhotdog.write(\"in a bun\"); // (D (O (G in a bun)))\n```\n\nBuns are convenient, edible, and keep your hands clean! Use **bun**!\n\n\nAPI\n---\n\n**bun**\n\n```js\nvar service = bun(streams, [options]);\n```\n\n* _streams_ - An array of `stream` objects.\n* _options_ - An object specifying options. (options are optional)\n\nOptions:\n\n* _bubbleErrors_ - Bubble \"error\" events from wrapped streams up to the outer\n  stream, giving you an easy way to aggregate and react to all the errors\n  emitted by them in one place. Default is `true`.\n\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n\n[build_status]: https://travis-ci.org/naomik/bun.png\n",
  "bugs": {
    "url": "https://github.com/naomik/bun/issues"
  },
  "_id": "bun@0.0.10",
  "_from": "bun@0.0.10"
}
